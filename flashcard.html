<!doctype html>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flashcards</title>
<style>
  body { font: 16px -apple-system, system-ui, sans-serif; margin: 18px; }
  .row { display:flex; gap:10px; flex-wrap:wrap; margin-bottom:12px; align-items:center; }
  button, a.btn { padding:10px 12px; border-radius:10px; border:1px solid #ccc; background:#fff; color:inherit; text-decoration:none; display:inline-block; }
  button:disabled { opacity: .45; }
  .card { border:1px solid #ccc; border-radius:14px; padding:18px; min-height:180px; }
  .front { font-size: 22px; font-weight:700; margin-bottom:10px; }
  .meta { opacity:.7; margin-top:10px; }
  .pill { padding:4px 10px; border-radius:999px; border:1px solid #ddd; }
  .hint { opacity:.75; font-style: italic; }
  .small { opacity:.7; font-size: 13px; margin-top: 10px; }

  /* Term strip */
  .termstrip {
    margin-top: 10px;
    padding: 10px 12px;
    border: 1px solid #ddd;
    border-radius: 14px;
    line-height: 1.6;
    font-size: 14px;
    word-break: break-word;
  }
  .termstrip a.term {
    color: inherit;
    text-decoration: none;
    cursor: pointer;
    border-radius: 8px;
    padding: 2px 4px;
  }
  .termstrip a.term:hover { text-decoration: underline; }
  .termstrip a.term.known { opacity: 0.35; }
  .termstrip a.term.current {
    font-weight: 800;
    font-size: 16px; /* a few points bigger */
  }
</style>

<div class="row">
  <a class="btn" href="index.html">← Decks</a>
  <span class="pill" id="deckTag">Deck: …</span>
  <span class="pill" id="knownPill">Known: 0</span>
  <span class="pill" id="status"></span>
</div>

<div class="row">
  <button id="mode">Front: Term</button>
  <button id="flip">Flip</button>
  <button id="prev">◀︎ Prev</button>
  <button id="next">Next ▶︎</button>
  <button id="shuffle">Shuffle</button>
  <button id="know">Know it ✓ (remove)</button>
  <button id="undo">Undo</button>
  <button id="reset">Reset</button>
</div>

<div class="card" id="card"></div>
<div class="small" id="deckInfo"></div>

<!-- Term list (comma separated) -->
<div class="termstrip" id="termStrip"></div>

<!-- Resume prompt -->
<div class="overlay" id="overlay" style="position:fixed; inset:0; background:rgba(0,0,0,.25); display:none; align-items:center; justify-content:center; padding:18px;">
  <div style="width:min(520px, 100%); background:#fff; border:1px solid #ddd; border-radius:16px; padding:16px;">
    <h2 style="font-size:18px; margin:0 0 8px;">Resume this deck?</h2>
    <p id="resumeText" style="margin:8px 0; opacity:.8;"></p>
    <div class="row" style="margin-top:12px;">
      <button id="resumeBtn">Resume</button>
      <button id="startOverBtn">Start over</button>
    </div>
  </div>
</div>

<script>
  // ---------------- Deck loading ----------------
  let CARDS = [];

  function getFolderParam() {
    const p = new URLSearchParams(location.search);
    const d = p.get("d");
    return d && d.trim() ? d.trim() : null;
  }

  function safeFolderName(folder) {
    if (!folder) return null;
    if (!/^[A-Za-z0-9_-]+$/.test(folder)) return null;
    return folder;
  }

  async function loadDeck(folder) {
    const deckInfoEl = document.getElementById("deckInfo");
    const deckTag = document.getElementById("deckTag");

    deckTag.textContent = folder ? `Deck: ${folder}` : "Deck: (missing)";
    if (!folder) throw new Error("Missing ?d= folder name");

    const path = `decks/${folder}/deck.json`;
    const res = await fetch(path, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to load ${path} (HTTP ${res.status})`);

    const data = await res.json();
    if (!Array.isArray(data)) throw new Error("deck.json must be an array of {term, def}");

    const cards = data
      .filter(x => x && typeof x.term === "string" && typeof x.def === "string")
      .map(x => ({ term: x.term.trim(), def: x.def.trim() }))
      .filter(x => x.term.length && x.def.length);

    if (!cards.length) throw new Error("No valid cards found in deck.json");

    CARDS = cards;
    deckInfoEl.textContent = `${path} (${CARDS.length} cards)`;
    return path;
  }

  // ---------------- Persistent state ----------------
  const KEY_PREFIX = "flashcards_v9:";

  function makeKey(deckId) { return KEY_PREFIX + deckId; }

  function freshState() {
    return {
      order: [...CARDS.keys()],
      known: Array(CARDS.length).fill(false),
      pos: 0,
      flipped: false,
      frontMode: "term",
      undo: []
    };
  }

  function clampPos(s) {
    if (s.order.length === 0) { s.pos = 0; return; }
    s.pos = Math.max(0, Math.min(s.pos, s.order.length - 1));
  }

  function normalizeKnownArray(s) {
    if (!Array.isArray(s.known) || s.known.length !== CARDS.length) {
      const k = Array(CARDS.length).fill(false);
      if (Array.isArray(s.known)) {
        for (let i = 0; i < Math.min(s.known.length, k.length); i++) k[i] = !!s.known[i];
      }
      s.known = k;
    } else {
      s.known = s.known.map(v => !!v);
    }
  }

  function loadState(key) {
    try {
      const s = JSON.parse(localStorage.getItem(key) || "null");
      if (!s) return null;

      const max = CARDS.length - 1;
      if (!Array.isArray(s.order)) return null;
      s.order = s.order.filter(n => Number.isInteger(n) && n >= 0 && n <= max);
      if (!s.order.length) return null;

      s.pos = Number.isInteger(s.pos) ? s.pos : 0;
      s.flipped = !!s.flipped;
      s.frontMode = (s.frontMode === "def") ? "def" : "term";

      normalizeKnownArray(s);

      s.undo = Array.isArray(s.undo) ? s.undo : [];
      s.undo = s.undo.filter(u => u && Number.isInteger(u.idx) && u.idx >= 0 && u.idx <= max);

      clampPos(s);
      return s;
    } catch {
      return null;
    }
  }

  function saveState(key, s) { localStorage.setItem(key, JSON.stringify(s)); }
  function clearState(key) { localStorage.removeItem(key); }

  // ---------------- Helpers ----------------
  function escapeHtml(str) {
    return str.replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  function currentIndex() {
    if (!state.order.length) return null;
    return state.order[state.pos];
  }

  function currentCard() {
    const idx = currentIndex();
    if (idx === null || idx === undefined) return null;
    return { idx, card: CARDS[idx] };
  }

  function frontText(card) { return state.frontMode === "term" ? card.term : card.def; }
  function backText(card)  { return state.frontMode === "term" ? card.def  : card.term; }

  function remainingCount() {
    let r = 0;
    for (let i = 0; i < state.known.length; i++) if (!state.known[i]) r++;
    return r;
  }

  function knownCount() { return CARDS.length - remainingCount(); }

  function stepNextUnknown(dir) {
    if (!state.order.length) return;
    const start = state.pos;
    let p = state.pos;

    while (true) {
      p += dir;
      if (p < 0 || p >= state.order.length) break;
      const idx = state.order[p];
      if (!state.known[idx]) { state.pos = p; return; }
    }
    state.pos = start;
  }

  function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // ---------------- App state ----------------
  let deckId = "unknown";
  let storageKey = makeKey(deckId);
  let state = null;

  function renderTermStrip() {
    const strip = document.getElementById("termStrip");
    const curIdx = currentIndex();

    const parts = state.order.map((idx, i) => {
      const term = escapeHtml(CARDS[idx].term);
      const classes = ["term"];
      if (state.known[idx]) classes.push("known");
      if (idx === curIdx) classes.push("current");

      // data-pos lets us jump exactly to this position in the current order
      return `<a class="${classes.join(" ")}" href="#" data-pos="${i}" title="Jump to: ${term}">${term}</a>`;
    });

    strip.innerHTML = parts.join(", ");
  }

  function render() {
    const c = currentCard();
    const total = CARDS.length;
    const remaining = remainingCount();

    document.getElementById("status").textContent = `Remaining: ${remaining} / ${total}`;
    document.getElementById("knownPill").textContent = `Known: ${knownCount()}`;
    document.getElementById("mode").textContent = state.frontMode === "term" ? "Front: Term" : "Front: Definition";

    const canNavigate = state.order.length > 0;
    const allKnown = remaining === 0;

    document.getElementById("flip").disabled = !canNavigate;
    document.getElementById("shuffle").disabled = state.order.length <= 1;
    document.getElementById("undo").disabled = state.undo.length === 0;

    const cur = currentIndex();
    document.getElementById("know").disabled = !canNavigate || allKnown || (cur !== null && state.known[cur]);
    document.getElementById("prev").disabled = !canNavigate || allKnown;
    document.getElementById("next").disabled = !canNavigate || allKnown;

    const el = document.getElementById("card");
    if (!c) {
      el.innerHTML = `
        <div class="front">No deck loaded</div>
        <div class="hint">Check the URL has ?d=YOUR_FOLDER and that /decks/YOUR_FOLDER/deck.json exists.</div>
      `;
      return;
    }

    if (allKnown) {
      el.innerHTML = `
        <div class="front">Deck cleared ✅</div>
        <div class="hint">Everything is marked known. Hit <b>Reset</b> to start again, or <b>Undo</b> to bring one back.</div>
      `;
      renderTermStrip();
      saveState(storageKey, state);
      return;
    }

    // If current is known, advance to next unknown
    if (state.known[c.idx]) {
      stepNextUnknown(+1);
      return render();
    }

    const show = state.flipped ? backText(c.card) : frontText(c.card);
    const hint = state.flipped ? "" : `<div class="hint">(tap Flip to reveal)</div>`;

    el.innerHTML = `
      <div class="front">${escapeHtml(show)}</div>
      ${state.flipped ? "" : hint}
      <div class="meta">${state.pos + 1}/${state.order.length}</div>
    `;

    renderTermStrip();
    saveState(storageKey, state);
  }

  // ---------------- Term strip click handler ----------------
  // Event delegation: one handler for all term links
  document.getElementById("termStrip").addEventListener("click", (e) => {
    const a = e.target.closest("a.term");
    if (!a) return;
    e.preventDefault();

    const pos = parseInt(a.dataset.pos, 10);
    if (!Number.isInteger(pos)) return;

    state.pos = Math.max(0, Math.min(pos, state.order.length - 1));
    state.flipped = false;

    // If user clicked a known term, hop to next unknown forward so it feels useful.
    const idx = currentIndex();
    if (idx !== null && state.known[idx] && remainingCount() > 0) {
      stepNextUnknown(+1);
    }

    render();

    // Optional: scroll card into view so tap on long strip doesn't leave you at bottom
    document.getElementById("card").scrollIntoView({ behavior: "smooth", block: "start" });
  });

  // ---------------- Controls ----------------
  document.getElementById("flip").onclick = () => { state.flipped = !state.flipped; render(); };

  document.getElementById("mode").onclick = () => {
    state.frontMode = (state.frontMode === "term") ? "def" : "term";
    state.flipped = false;
    render();
  };

  document.getElementById("next").onclick = () => {
    state.flipped = false;
    stepNextUnknown(+1);
    render();
  };

  document.getElementById("prev").onclick = () => {
    state.flipped = false;
    stepNextUnknown(-1);
    render();
  };

  document.getElementById("shuffle").onclick = () => {
    shuffleArray(state.order);
    state.pos = 0;
    state.flipped = false;
    if (state.order.length && state.known[state.order[state.pos]]) stepNextUnknown(+1);
    render();
  };

  document.getElementById("know").onclick = () => {
    const idx = currentIndex();
    if (idx === null || state.known[idx]) return;

    state.undo.push({ idx, prevKnown: false, prevPos: state.pos });
    state.known[idx] = true;

    state.flipped = false;
    stepNextUnknown(+1);
    render();
  };

  document.getElementById("undo").onclick = () => {
    const last = state.undo.pop();
    if (!last) return;

    state.known[last.idx] = last.prevKnown;
    state.pos = Math.max(0, Math.min(last.prevPos, state.order.length - 1));
    state.flipped = false;

    render();
  };

  document.getElementById("reset").onclick = () => {
    state = freshState();
    clearState(storageKey);
    hideResumePrompt();
    render();
  };

  document.getElementById("card").onclick = () => {
    if (!state || remainingCount() === 0) return;
    state.flipped = !state.flipped;
    render();
  };

  // ---------------- Resume prompt ----------------
  function showResumePrompt(savedState) {
    const overlay = document.getElementById("overlay");
    const resumeText = document.getElementById("resumeText");

    let k = 0; for (let i = 0; i < savedState.known.length; i++) if (savedState.known[i]) k++;
    const remaining = CARDS.length - k;

    resumeText.textContent = `You previously marked ${k} known and have ${remaining} remaining in this deck.`;
    overlay.style.display = "flex";

    document.getElementById("resumeBtn").onclick = () => {
      state = savedState;
      overlay.style.display = "none";
      if (remainingCount() > 0 && state.known[state.order[state.pos]]) stepNextUnknown(+1);
      render();
    };

    document.getElementById("startOverBtn").onclick = () => {
      clearState(storageKey);
      state = freshState();
      overlay.style.display = "none";
      render();
    };
  }

  function hideResumePrompt() {
    document.getElementById("overlay").style.display = "none";
  }

  // ---------------- Boot ----------------
  (async function init() {
    const folder = safeFolderName(getFolderParam());
    const deckInfoEl = document.getElementById("deckInfo");

    try {
      const path = await loadDeck(folder);
      deckId = path;
      storageKey = makeKey(deckId);

      const saved = loadState(storageKey);
      if (saved) showResumePrompt(saved);
      else { state = freshState(); render(); }

    } catch (e) {
      deckInfoEl.textContent = "Error: " + e.message;
      document.getElementById("card").innerHTML = `
        <div class="front">Couldn’t load deck</div>
        <div class="hint">Check the URL has ?d=YOUR_FOLDER and that /decks/YOUR_FOLDER/deck.json exists.</div>
      `;
    }
  })();
</script>
